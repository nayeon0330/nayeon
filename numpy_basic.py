# -*- coding: utf-8 -*-
"""
Created on Thu Dec 20 16:00 2021

Numpy에 대한 정리

리스트 : 여러 개의 다양한 값들을 저장할 수 있는 자료 구조

데이터 과학에서는 
파이썬의 기본 리스트로는 처리 속도문제 때문에..
리스트 간의 연산..

리스트 보다 Numpy를 선호

Numpy : 대용량의 배열(다차원)과 행렬 연산을 빠르게 수행.
        고차원의 수학 연산자와 함수를 포함
        파이썬의 리스트 보다 처리 속도가 매우 빠르다
        
Numpy의 핵심 객체는 다차원 배열
ex. 정수들의 2차원 배열(테이블)을 Numpy를 이용하여 생성 가능
    배열의 각 요소는 index라고 불리는 정수들로 참조

Numpy에서 차원은 축(axis)라고도 한다..

Numpy 배열 : ndarray 객체
1. C언어를 기반으로 한 배열 구조
2. 메모리를 적게 차지하고, 속도가 빠르다..
3. ndarray를 이용하면 배열과 배열간의 수학적인 연산을 적용할 수 있다.
4. ndarray는 고급 연산자 풍부한 함수를 제공
"""

### Numpy 배열과 리스트의 차이점
# ex. 학생들의 중간고사와 기말고사 성적을 저장하는 리스트
mid_scores = [10, 20, 30]      # 중간고사
final_scores = [70, 80, 90]    # 기말고사

## 중간고사 성적과 기말고사 성적을 합하여 총점을 만들 경우,
total = mid_scores + final_scores
'''
중간 + 기말고사 점수가 합산되서 나온 결과값이 아닌,
두개의 값만 한 리스트에 연결되어서 결과 추출..
[10, 20, 30, 70, 80, 90]
'''

## Numpy의 배열을 이용
import numpy as np

# 1. Numpy 배열을 만들려면 Numpy가 제공하는 array()를 이용
# 2. array() 함수에 파이썬 리스트를 전달.
mid_scores = np.array([10, 20, 30]) 
final_scores = np.array([70, 80, 90])

type(mid_scores)      # numpy.ndarray
type(final_scores)    # numpy.ndarray

total = mid_scores + final_scores
'''
array([ 80, 100, 120])
'''

avg = total / 2
'''
array([40., 50., 60.])
'''

"""
리스트간의 + 연산 : 리스트를 연결
Numpy의 배열간의 + 연산 : 데이터간의 연산
"""

### Numpy의 핵심 다차원 배열 : ndarray
## Numpy의 array()에게 파이썬 리스트를 전달.
a = np.array([1, 2, 3])
'''
array([1, 2, 3])
'''

## ndarray의 여러가지 속성
# 프로그램 오류(결과값)나 배열의 상세한 정보를 조회.

# 1. ndarray의 형태 : shape
print(a.shape)
'''
1차원 배열 : 3개의 데이터
(3,)
'''

# 2. ndarray의 차원: ndim
print(a.ndim)
'''
1
'''

# 3. ndarray의 내부 데이터타입(자료형) : dtype
print(a.dtype)
'''
내부 데이터 정수 형태
int32
'''

# 4. ndarray의 내부 자료형이 차지하는 메모리 크기(byte 단위) : itemsize
print(a.itemsize)
'''
4
'''

# 5. ndarray의 데이터 갯수 : size
print(a.size)
'''
3
'''



### ndarray 객체 생성 및 속성
# 1. 파이썬의 리스트 데이터로 생성
array_a = np.array([0, 1, 2, 3, 4, 5, 7, 8, 9])
'''
array([0, 1, 2, 3, 4, 5, 7, 8, 9])
'''

type(array_a)    # numpy.ndarray
 
# 2. 파이썬의 range()를 이용하여 생성
array_b = np.array(range(10))
'''
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
'''

type(array_b)    # numpy.ndarray


# 3. 파이썬의 range()를 이용하여 생성
array_c = np.array(range(0, 10, 2))
'''
array([0, 2, 4, 6, 8])
'''

type(array_c)    # numpy.ndarray

print(array_c.shape)     # (5,)
print(array_c.ndim)      # 1
print(array_c.dtype)     # int32
print(array_c.size)      # 5
print(array_c.itemsize)  # 4



### Numpy 배열의 연산
"""
Numpy 배열에는 + 연산자나 * 연산자와 같은 수학적인 연산자를 얼마든지 적용할 수 있다.

ex. 어떤 회사가 좋은 성과를 거두어 전 직원의 급여를 100만원씩 올려주기로 했다.
    현재 직원들의 급여는 [220, 250, 330]이라고 가정
"""
salary = np.array([220, 250, 330])
'''
array([220, 250, 330])
'''

salary = salary + 100
'''
array([320, 350, 430])
'''

# ex. 급여를 두배 인상
salary = np.array([220, 250, 330])

salary = salary * 2 
'''
array([440, 500, 660])
'''

# ex. 급여를 2.5배 인상
salary = np.array([220, 250, 330])

salary = salary * 2.5 
'''
array([550., 625., 825.])
'''



### Numpy의 계산이 빠른 이유
"""
Numpy는 각 배열마다 타입이 하나만 존재한다고 인식.
=> Numpy는 배열 안에 하나의 타입만 저장 가능..
=> Numpy의 배열에 문자와 숫자를 혼용하여 저장할 경우 : 모든 데이터를 문자열로 변경
"""
test = np.array([10, 20, 'test', 3.0, False])
'''
전부 문자열로 변환...
array(['10', '20', 'test', '3.0', 'False'], dtype='<U32')
'''

type(test)   # numpy.ndarray


## BMI 구하기 : BMI = 체중(키**2)
heights = [ 1.83, 1.76, 1.69, 1.86, 1.77, 1.73 ]   # 키
weights = [ 86,    74,    59,   95,    80,   68  ] # 몸무게

np_heights = np.array(heights)
np_weights = np.array(weights)

bmi = np_weights / (np_heights**2)
'''
array([25.68007405, 23.88946281, 20.65754, 27.45982194, 25.53544639,
       22.72043837])
'''



### Numpy 배열의 인덱싱 / 슬라이싱
"""
Numpy 배열에서 특정 요소(데이터)를 추출 : index를 이용
파이썬 리스트와 동일하게 index는 0부터 시작
"""

scores = np.array([88, 72, 93, 94, 89, 78, 99])

# 1. index를 이용한 추출
print(scores[2])
'''
93
'''

# 2. 마지막 요소 : -1
print(scores[-1])
'''
99
'''

# 3. slicing : [시작index : 종료index] 단, 종료index-1 까지
"""

        -7  -6  -5  -4  -3  -2  -1
        0   1   2   3   4   5   6
array([88, 72, 93, 94, 89, 78, 99])

"""
print(scores[1:4])
'''
[72 93 94]
'''

print(scores[3:])
'''
[94 89 78 99]
'''

print(scores[4:-1])
'''
[89 78]
'''



### 논리적인 인덱싱 : 조건에 따른 결과를 True / False 로 반환
"""
 ex. 사람들의 나이를 저장하고 있는 Numpy배열이 있다고 가정,
     20세 이상인 사람들을 확인
"""
ages = np.array([18, 19, 25, 30, 28])

y = ages > 20
'''
array([False, False,  True,  True,  True])
'''

print(ages[ages > 20])
'''
[25 30 28]
'''



### 2차원 배열 생성 및 인덱싱 방법
"""
파이썬의 2차원 리스트 : [[], [], ...]
=> 행렬 연산을 지원하지 않는다!!!

Numpy의 2차원 배열 : 행렬 연산을 지원
=> 수학에서의 행렬과 같이 다룰 수 있고, 
   역행렬, 행렬식을 구하는 등의 행렬 연산들을 쉽게 적용할 수 있도록 구현되어 있다. 
"""

## 1. 2차원 배열 생성 : 파이썬의 2차원 리스트를 Numpy의 array()에게 전달
# 파이썬의 2차원 배열(리스트)
y = [[1,2,3], [4,5,6], [7,8,9]]
'''
[[1, 2, 3], [4, 5, 6], [7, 8, 9]]
'''

np_array2d = np.array(y)
'''
array([[1, 2, 3],
       [4, 5, 6],
       [7, 8, 9]])
'''

type(np_array2d)        # numpy.ndarray
type(np_array2d.shape)  # tuple
type(np_array2d.ndim)   # int


## 2. 2차원 배열 인덱싱 : [첫번째 index] [두번째 index]
"""
  => 가로 방향 : 두번째 index
        -3    -1  
        0  1  2
array([[1, 2, 3],   0
       [4, 5, 6],   1
       [7, 8, 9]])  2
  => 세로 방향 : 첫번째 index
"""
print(np_array2d[0][0])   # 1

print(np_array2d[0][2])   # 3

print(np_array2d[1][0])   # 4

print(np_array2d[2][2])   # 9
print(np_array2d[2][-1])  # 9


# 특정 위치의 값 변경 : [첫번째 index][두번째 index]
np_array2d[2][-1] = 999
'''
array([[  1,   2,   3],
       [  4,   5,   6],
       [  7,   8, 999]])
'''

# 특정 위치의 값 변경 : [첫번째 index][두번째 index] = 새로운 값 (기존 타입이 아닌 실수일 경우 오류)
np_array2d[2][2] = 99.9
'''
array([[ 1,  2,  3],
       [ 4,  5,  6],
       [ 7,  8, 99]])

[2][2]에 해당하는 값을 99.9로 저장하려고 해도
Numpy의 배열은 한가지 타입만 인식하기 때문에, 99.9가 아닌 99로 저장된다!!!
'''

np_array2d[0][0] = 'test'
'''
문자형 숫자가 아니기 때문에 변환 자체가 불가능.. 따라서 오류 발생
ValueError : invalid literal for int() with base 10: 'test'
'''

np_array2d[0][0] = '999'
'''
array([[999,   2,   3],
       [  4,   5,   6],
       [  7,   8,  99]])
문자형 숫자는 정수로 변환하여 저장.
'''

np_array2d[0][0] = '99.9'
'''
ValueError : invalid literal for int() with base 10: '99.9'
문자형 숫자이지만 정수로 변환하지 못하므로 오류 발생
'''


## 3. Numpy 스타일로 인덱싱 : [행index, 열index]
print(np_array2d[0, 1])
'''
2
'''

"""
주의사항

2차원 Numpy 배열은 행렬!!!
=> 행렬은 행의 번호와 열의 번호만 있으면 해당 요소에 바로 접근 가능
"""
np_array2d[0, 1] = 112
'''
array([[999, 112,   3],
       [  4,   5,   6],
       [  7,   8,  99]])
'''



### Numpy 2차원 배열 슬라이싱
np_array = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
'''
        0  1  2
array([[1, 2, 3],   0
       [4, 5, 6],   1
       [7, 8, 9]])  2
'''
np_array[0:2, 1:3]
'''
array([[2, 3],
       [5, 6]])

       0  1  2
0:2 : [1, 2, 3],
      [4, 5, 6]

1:3 : [2, 3],
      [5, 6]
'''
"""
2차원 배열의 슬라이싱은 
큰 행렬에서 작은 행렬을 추출하는 형태
즉, 1. 행에 관련된 데이터들을 추출하고, 
    2. 그 데이터로부터 열에 해당하는 데이터를 추출
"""

# 2차원 배열에서 한 행(0번 행)을 슬라이싱
np_array[0]
'''
        0  1  2
array([[1, 2, 3],   0
       [4, 5, 6],   1
       [7, 8, 9]])  2

array([1, 2, 3])
'''

# 2차원 배열에서 한 행(1번 행)을 슬라이싱한 후, 1번열과 2번열 값을 슬라이싱
np_array[1, 1:3]
'''
        0  1  2
array([[1, 2, 3],   0
       [4, 5, 6],   1
       [7, 8, 9]])  2

array([5, 6])
'''

np_array4x4 = np.array([[ 1,  2,  3,  4], 
                     [ 5,  6,  7,  8], 
                     [ 9, 10, 11, 12], 
                     [13, 14, 15, 16]])
'''
         0   1   2   3
array([[ 1,  2,  3,  4],   0 
       [ 5,  6,  7,  8],   1
       [ 9, 10, 11, 12],   2
       [13, 14, 15, 16]])  3
'''

# np_array4x4의 첫 행(0번 행)
np_array4x4[0]
'''
array([1, 2, 3, 4])
'''

# np_array4x4의 두번째 행(1번 행)의 모든 열
np_array4x4[1, :]
'''
array([5, 6, 7, 8])
'''

# np_array4x4의 세번째 열(2번 열)
np_array4x4[:, 2]
'''
array([ 3,  7, 11, 15])
'''

# np_array4x4의 첫번째, 두번째 행과 첫번째, 두번째 열
np_array4x4[0:2, 0:2]
'''
array([[1, 2],
       [5, 6]])
'''

# np_array4x4의 첫번째, 두번째 행과 세번째, 네번째 열
np_array4x4[0:2, 2:4]
'''
array([[3, 4],
       [7, 8]])
'''

# np_array4x4 자체
'''
         0   1   2   3
array([[ 1,  2,  3,  4],   0 
       [ 5,  6,  7,  8],   1
       [ 9, 10, 11, 12],   2
       [13, 14, 15, 16]])  3
'''

# np_array4x4의 첫번째, 세번째 행과 첫번째, 세번째 열
np_array4x4[::2, ::2]
'''
array([[ 1,  3],
       [ 9, 11]])
'''

# np_array4x4의 두번째, 네번째 행과 두번째, 네번째 열
np_array4x4[1::2, 1::2]
'''
array([[ 6,  8],
       [14, 16]])
'''

### 주의사항 : 동일한 범위를 저장하더라도
#              파이썬의 리스트 슬라이싱 방법의 결과와
#              Numpy의 스타일 방법의 결과는 다르다..

# np_array4x4 자체
'''
         0   1   2   3
array([[ 1,  2,  3,  4],   0 
       [ 5,  6,  7,  8],   1
       [ 9, 10, 11, 12],   2
       [13, 14, 15, 16]])  3
'''


## 1. 파이썬의 리스트 슬라이싱 방법의 결과
np_array4x4[1::2][1::2]
'''
array([[13, 14, 15, 16]])
'''
## 2. Numpy의 스타일 방법의 결과
np_array4x4[1::2, 1::2]
'''
array([[ 6,  8],
       [14, 16]])
'''



### 2차원 배열에서의 논리적인 인덱싱
"""
1에서 9까지의 값이 들어 있는 2차원 배열에서 
5 보다 작은 값들을 확인
"""
# 1. 1에서 9까지의 값이 들어 있는 2차원 배열에서 
np_array = np.array([[1,2,3], [4,5,6], [7,8,9]])
'''
array([[1, 2, 3],
       [4, 5, 6],
       [7, 8, 9]])
'''

# 2. 5 보다 작은 값들을 확인
print(np_array > 5)
'''
[[False False False]
 [False False  True]
 [ True  True  True]]
'''

# 3. 조건(5 보다 작은 값)에 맞는 값들만 출력
print(np_array[np_array > 5])
'''
[6 7 8 9]
'''

# 4. 특정 값에 해당하는 열을 추출한 후, 조건 비교
np_array = np.array([[1,2,3], [4,5,6], [7,8,9]])
'''
array([[1, 2, 3],
       [4, 5, 6],
       [7, 8, 9]])
'''

print(np_array[:, 2] > 5)
'''
np_array[:, 2] => array([3, 6, 9])

np_array[:, 2] > 5 => [False  True  True]
'''

# 5. 짝수(%2 == 0)에 해당하는 값 구하기
print(np_array[:] %2 == 0)
'''
[[False  True False]
 [ True False  True]
 [False  True False]]
'''

print(np_array[np_array[:] %2 == 0])
'''
[2 4 6 8]
'''



### 문자 데이터를 이용한 슬라이싱 
"""
'a' ~ 'h' 까지의 문자 데이터를 저장하는 2차 배열 내에서 'c'에 해당하는 데이터만 추출
"""
x = np.array( [['a', 'b', 'c', 'd'],
               ['c', 'c', 'g', 'h']])
'''
array([['a', 'b', 'c', 'd'],
       ['c', 'c', 'g', 'h']], dtype='<U1')
'''

print(x[x =='c'])
'''
['c' 'c' 'c']
'''



### 동일한 구조를 갖고 있는 두개의 2차원 배열을 합하기
mat_a = np.array( [[10, 20, 30], [10, 20, 30]])
mat_b = np.array( [[2, 2, 2], [1, 2, 3]])
'''
mat_a
array([[10, 20, 30],
       [10, 20, 30]])

mat_b
array([[2, 2, 2],
       [1, 2, 3]])
'''

print(mat_a + mat_b)
'''
[[12 22 32]
 [11 22 33]]
'''




### 다른 구조를 갖고 있는 두개의 2차원 배열을 합하기 : 오류 발생
mat_a = np.array( [[10, 20, 30], [10, 20, 30], [10, 20, 30]])
mat_b = np.array( [[2, 2, 2], [1, 2, 3]])

print(mat_a + mat_b)
'''
ValueError: operands could not be broadcast together with shapes (3,3) (2,3) 
'''



### 키와 몸무게를 갖는 2차원 배열 생성
x = np.array([[ 1.83, 1.76, 1.69, 1.86, 1.77, 1.73 ],   
              [ 86.0, 74.0, 59.0, 95.0, 80.0, 68.0 ]])
'''
           0      1      2      3     4       5
array([[ 1.83,  1.76,  1.69,  1.86,  1.77,  1.73],   0
       [86.  , 74.  , 59.  , 95.  , 80.  , 68.  ]])  1
'''

y = x[0:2, 1:3]
'''
array([[ 1.76,  1.69],
       [74.  , 59.  ]])
'''

z = x[0:2][1:3]
'''
array([[86., 74., 59., 95., 80., 68.]])
'''

print('x의 shape : ', x.shape)
print('y의 shape : ', y.shape)
print('z의 shape : ', z.shape)
'''
x의 shape :  (2, 6)
y의 shape :  (2, 2)
z의 shape :  (1, 6)
'''

# BMI = w / (h**2)
bmi = x[1] / (x[0]**2)
'''
array([25.68007405, 23.88946281, 20.65754, 27.45982194, 25.53544639, 22.72043837])
'''



### 2차원 배열에서 특정 조건에 맞는 행만 추출
"""
ex. 선수들의 키와 몸무게를 갖는 리스트가 있다고 가정,
    선수들 가운데 몸무게가 80kg 이상인 선수들의 정보만 출력
"""
#           키   몸무게
players = [[170, 76.4], 
           [183, 86.2], 
           [181, 78.5], 
           [176, 80.1]]
'''
 [[170, 76.4], [183, 86.2], [181, 78.5], [176, 80.1]]
'''

# 1. 파이썬 리스트를 Numpy 2차원 배열로 변환
np_players = np.array(players)
'''
array([[170. ,  76.4],
       [183. ,  86.2],
       [181. ,  78.5],
       [176. ,  80.1]])
'''
print('몸무게가 80 이상인 선수들의 정보 : ', np_players[np_players[:, 1] >= 80])
'''
몸무게가 80 이상인 선수들의 정보 :  [[183.   86.2]
                                  [176.   80.1]]
'''

print('키가 180 이상인 선수들의 정보 : ',np_players[np_players[:, 0] >= 180])
'''
키가 180 이상인 선수들의 정보 :  [[183.   86.2]
                                [181.   78.5]]
'''



### Numpy의 arange() : 파이썬의 range()와 유사하지만, Numpy 배열로 반환
""" 
Numpy.arange([start], stop, [step])
      start : 데이터 생성 시작값 (생략 가능, 생략시에는 0으로 자동 설정)
      stop : 데이터 생성을 멈출 수 있는 값으로 생략 불가!!!
      step : 데이터 생성 간격 (생략 가능하고, 생략시 1로 자동 설정)
"""
a_range = np.arange(0, 5, 1)
'''
array([0, 1, 2, 3, 4])
'''

# stop만 설정
a_range = np.arange(5)
'''
array([0, 1, 2, 3, 4])
'''

# 시작 값과 종료 값
a_range = np.arange(5, 15)
'''
array([ 5,  6,  7,  8,  9, 10, 11, 12, 13, 14])
'''

# 시작 값과 종료 값, 생성 간격
a_range = np.arange(5, 15, 3)
'''
array([ 5,  8, 11, 14])
'''

type(a_range)   # numpy.ndarray


# 파이썬의 range()
py_range = range(5)
type(py_range)  # range

list_range = list(py_range)
'''
[0, 1, 2, 3, 4]
'''

type(list_range) # list


## 파이썬의 range()를 이용하여 Numpy 배열 생성
# 1. list()로 선언
r1 = np.array(list_range)
'''
array([0, 1, 2, 3, 4])
'''

type(r1)  # numpy.ndarray

# array() 에게 range()를 전달
r2 = np.array(range(5))
'''
array([0, 1, 2, 3, 4])
'''

type(r2)  # numpy.ndarray



### 균일 간격으로 데이터를 생성 : linspace() / logspace()
"""
일반 숫자를 균일하게
linspace(start, stop, num=갯수) 
    start : 데이터 생성 시작값, 생략 불가능!!!
    stop  : 데이터 생성 종료값
    num=  : 데이터 생성 갯수, 기본값은 50개
    
로그값으로 균일하게
logspace(start, stop, num=갯수)
    start : 데이터 생성 시작값, 생략 불가능!!!
    stop  : 데이터 생성 종료값
    num=  : 데이터 생성 갯수, 기본값은 50개
"""
space1 = np.linspace(0, 10, 10)
'''
array([ 0.        ,  1.11111111,  2.22222222,  3.33333333,  4.44444444,
        5.55555556,  6.66666667,  7.77777778,  8.88888889, 10.        ])

0 부터 10까지, 총 10개의 수들이 생성
'''

space2 = np.logspace(0, 10, 10)
'''
array([1.00000000e+00, 1.29154967e+01, 1.66810054e+02, 2.15443469e+03,
       2.78255940e+04, 3.59381366e+05, 4.64158883e+06, 5.99484250e+07,
       7.74263683e+08, 1.00000000e+10])

10의 0 부터 10의 10까지, 총 10개의 수들이 생성
'''



### 배열의 형태를 바꾸기 : reshape()
"""
배열의 데이터 갯수는 유지한 채로
배열의 차원과 형태를 변경.
튜플 형태로 전달하는 것이 원칙
이미지 데이터 처리할때 많이 사용된다...
"""
y = np.arange(12)
'''
array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11])
'''

y_reshape = y.reshape((3, 4))
'''
array([[ 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11]])
'''

y_reshape = y.reshape(3, 4)
'''
array([[ 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11]])

튜플 형태 생략 가능
'''

### 단, 데이터의 갯수와 행 x 열의 값이 일치해야 한다..

# 데이터의 갯수에 맞추어서 자동으로 배열의 형태가 만들어지는 경우
# (6, -1)와 같이 -1을 전달할 경우...

y.reshape(6, -1)
'''
array([[ 0,  1],
       [ 2,  3],
       [ 4,  5],
       [ 6,  7],
       [ 8,  9],
       [10, 11]])
'''



#### 2차원 배열을 1차원 배열로 변환 : flatten()
y = np.arange(12)
'''
array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11])
'''

y_reshape = y.reshape(3, 4)
'''
array([[ 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11]])
'''

y_shape = y_reshape.flatten()
'''
array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11])
'''

"""
linspace() / reshape() / flatten()
이 세가지는 이미지 데이터 처리 및 러닝 쪽에서 필수로 많이 사용되는 대표적인 Numpy 함수들
"""



### Numpy 난수(Random Number)
"""
난수 : 무작위성의 특징을 가지고 추출되는 수를 의미
무작위성 : 특정한 패턴이 존재하지 않아서 다음에 어떤 수가 나타날지를 예상(예측)할 수 없는 것

1. rand() : 0과 1 사이의 실수값을 이용하여 무작위로 추출된 임의의 수들로 이루어진 행렬을 반환

2. randint() : 지정한 범위내에서 정수값을 무작위로 추출된 임의의 수들로 이루어진 행렬로 반환 

3. seed() : 동일한 임의의 수를 생성할때 지정. (임의의 + 값으로 설정)

4. randn() : 맨 마지막 n은 정규분포를 의미.
             정규분포 형태를 가진 임의의 수들로 구성된 행렬을 반환
5. choice() : 주어진 1차원 배열(행렬)로부터 임의의 수를 샘플링 하는 함수             
"""

# 1. rand(추출할 임의의 수에 대한 갯수)
#    실행할 때마다 결과값이 바뀌어서 출력된다..
np.random.rand(5)
'''
array([0.63273469, 0.89887607, 0.9618204 , 0.20755369, 0.65140522])
'''

np.random.rand(5)
'''
array([0.34243249, 0.36895879, 0.13947332, 0.10784445, 0.26544582])
'''

np.random.rand(5)
'''
array([0.61343575, 0.34048813, 0.02846788, 0.50810488, 0.25617854])
'''

# 2. seed(임의의 양의 정수) : 기계학습에서 많이 사용
#    seed로 입력값 고정하면 동일한 값이 출력..
np.random.seed(3)
np.random.rand(5)
'''
array([0.5507979 , 0.70814782, 0.29090474, 0.51082761, 0.89294695])
'''
np.random.seed(3)
np.random.rand(5)
'''
array([0.5507979 , 0.70814782, 0.29090474, 0.51082761, 0.89294695])
'''

np.random.seed(3)
np.random.rand(5)
'''
array([0.5507979 , 0.70814782, 0.29090474, 0.51082761, 0.89294695])
'''

# 3. randint(범위)
# 범위 : 시작, 끝, 차원
# 1 ~ 7까지의 숫자 중에 임의의 수를 1차원 배열로 10개의 수 곱하기
np.random.randint(1, 7, size=10)     
'''
array([3, 4, 2, 2, 3, 6, 1, 5, 5, 6])
'''

np.random.randint(1, 11, size=(4, 7))
'''
4열 7행으로 수를 반환..
array([[ 8,  9,  2,  7,  3,  3,  2],
       [ 4,  6,  9,  2,  9,  8,  9],
       [ 2,  1,  6,  5,  2,  6,  5],
       [ 8,  7,  1,  1, 10,  3,  5]])
'''

np.random.rand(14)
# 1, 2, 3차 배열인지는 대괄호로 구분
'''
1차원
array([0.37799404, 0.09221701, 0.6534109 , 0.55784076, 0.36156476,
       0.2250545 , 0.40651992, 0.46894025, 0.26923558, 0.29179277,
       0.4576864 , 0.86053391, 0.5862529 , 0.28348786])
'''

np.random.rand(4, 3)
'''
4행 3열 2차원
array([[0.27797751, 0.45462208, 0.20541034],
       [0.20137871, 0.51403506, 0.08722937],
       [0.48358553, 0.36217621, 0.70768662],
       [0.74674622, 0.69109292, 0.68918041]])
'''

np.random.rand(2, 3, 4)
'''
3차원
array([[[0.37360012, 0.6681348 , 0.33984866, 0.57279387],
        [0.32580716, 0.44514505, 0.06152893, 0.24267542],
        [0.97160261, 0.2305842 , 0.69147751, 0.65047686]],

       [[0.72393914, 0.47508861, 0.59666377, 0.06696942],
        [0.07256214, 0.19897603, 0.151861  , 0.10010434],
        [0.12929386, 0.55327773, 0.18781482, 0.95210124]]])
'''


## 정규 분포 난수 생성
"""
정규 분포 : 데이터에 대한 분포도
            대칭 형태를 이룬다.
            
확률 분포 : 평균값에서 가장 높고, 평균값에서 멀수록 발생 확률이 낮아진다.
표준 편차가 크면 클수록, 데이터의 흩어짐이 크기 때문에,
발생확률은 평평하게 펴진 상태에 접근하게 된다.

randn()             
"""

np.random.randn(5)
'''
array([ 0.43794661,  1.93897846, -1.02493087,  0.89933845, -0.15450685])
'''

np.random.randn(5, 4)
'''
array([[ 1.7696273 ,  0.48378835,  0.6762164 ,  0.64316328],
       [ 0.24908671, -1.3957635 ,  1.39166291, -1.37066901],
       [ 0.23856319,  0.61407709, -0.83791227,  0.14506321],
       [ 1.16788229, -0.02410447, -0.88865742, -2.91573775],
       [-0.9718405 , -0.59107874, -0.51641737, -0.95999618]])
'''

"""
왜도(편포도) : 요약 분포가 대칭을 벗어나 한쪽으로 치우친 정도

분포의 형태
1. 균등 분포 : 점수가 고르게 분포되어 있는 형태
2. 대칭 분포 : 점수가 좌우 대칭적인 곡선으로 분포되어 있는 형태
3. 편포      : 한쪽으로 치우친 형태
 
편포에서는
가장 빈번하게 발생하는 수치들이 중앙에 모여 있지 않고,
대신 분포의 낮거나, 높은 쪽에 편중되어 모여 있다.

편포
1. 정적 편포
    분포의 꼬리가 높은 점수쪽으로 뻗어 있고, 
    분포의 낮은 점수쪽에 몰려 있는 형태

2. 부적 편포
    분포의 꼬리가 점수의 낮은쪽으로 뻗어 있고,
    분포의 높은 점수쪽에 점수가 몰려 있는 형태
    
편포도 : 평균, 중앙값, 최빈값 (집중경향치)를 알아보는 것.

평균 : 극단적으로 높거나, 낮은 점수들에 영향을 받기 때문에,
       극단적인 점수가 발견되는 분포의 지역을 향해서 끌려가는 형태.

중앙값 : 한가운데 값 (1, 2, 3, 4, 5 : 3이 중앙값 / 정중앙에 있는 값.)
         극단적인 값들에 영향을 받지 않고, 대신 점수들의 위치에 영향을 받는다.
         따라서, 극단적인 값들은 평균에 비해 중앙값에 미치는 영향이 적다. 

최빈값 : 극단적인 값에 영향을 받지 않으며,
         최빈값은 분포의 어느 양끝에 의해서도 영향을 받지 않는다.
         
부적 편포 : 평균 < 중앙값 < 최빈값
정적 편포 : 평균 > 중앙값 > 최빈값
정상 분포 : 평균 == 중앙값 == 최빈값 


첨도 : 도수분포의 뾰족한 정도
       분포의 정점은 평균을 중심으로 각 점수의 위치에 따라 영향을 받는다.
       
1. 중첨 : 정규 분포 모양
2. 고첨 : 정규 분포 보다 더 뾰족한 모양
3. 저첨 : 정규 분포 보다 더 완만한 모양
"""


## 주어진 데이터로부터 임의의 샘플링 데이터 추출 : choice(데이터, 차원, 기존데이터에 적용 여부)
sr= np.array([1, 2, 3, 1.5, 2.6, 4.9,10,1.1,1.2])
'''
 array([ 1. ,  2. ,  3. ,  1.5,  2.6,  4.9, 10. ,  1.1,  1.2])
'''

x1 = np.random.choice(sr, size=(3, ), replace=False)
'''
 array([1. , 3. , 4.9])
'''


## 평균값과 중앙값 계산
## 1. 모든 데이터를 0으로 채워주는 함수 : Numpy zeros((행, 열))
players = np.zeros((100, 3))

# 임의의 키(신장) : 0으로 채워진 배열(행열)의 첫번째 열에 임의의 키(신장) 값을 생성
players[:, 0] = 10 * np.random.randn(100) + 175

# 임의의 체중 : 두번째 열에 임의의 체중 값을 생성
players[:, 1] = 10 * np.random.randn(100) + 70

# 임의의 나이 : 세번째 임의의 나이 값을 생성
players[:, 2] = np.floor(10 * np.random.randn(100) + 22)
'''
array([[178.77295234,  71.17763446,  12.        ],
       [172.67373066,  79.34303274,  36.        ],
       [177.20500136,  65.50001871,   7.        ],
       [169.75790925,  80.67468856,  25.        ],
       [205.18694186,  67.1945851 ,  28.        ],
       [180.88647607,  68.12951507,  25.        ],
       [169.88904242,  71.40586276,  15.        ],
       [173.95411437,  78.17608398,  32.        ],
       ~~~~~~
'''

# 2. 평균값 구하기 : Numpy.mean()
print('평균 신장 : ', np.mean(players[:, 0]))
'''
평균 신장 :  175.8320888879526
'''

## 3. 중앙값 구하기 : 
print('신장 중앙값 : ', np.median(players[:, 0]))
## 두 변수 간 상관 관계 계산
'''
신장 중앙값 :  174.8904537676835
'''

"""
참고 : 데이터의 갯수가 홀수일 경우Numpy.median() : 한 가운데 값 추출
       데이터의 갯수가 짝수일 경우 : 한 가운데 해당하는 두개의 값에 대한 평균값 추출
"""          


## 두 변수 간 상관관계 계산 : Numpy.corrcoef(x, y)
"""
상관관계 : 두 가지의 값에 대한 연관성(관련성)
ex. 키가 큰 사람은 몸무게가 키가 작은 사람들에 비해 많이 나간다..

     Numpy.corrcoef(x, y)
     x와 y : 데이터를 담고 있는 리스트나 배열이 될 수 있다.
     
     반환되는 결과는 
     x와 / x 와 y / y 와 x / y와 y에 대한 상관관계 계수를
     행렬로 반환
"""
# 0 ~ 99 까지의 값
x = [i for i in range(100)]

# 0 ~ 99 까지의 값의 제곱
y = [i**2 for i in range(100)]

result = np.corrcoef(x, y)
print(result)
'''
       x          y   
   x [[1.         0.96764439]
   y  [0.96764439 1.        ]]
   
   x값이 증가함에 따라 y값도 증가
   따라서, x와 y의 데이터는 서로 양(+)의 밀접한 관계(상관 관계)가 있다.
'''

"""
상관 관계 계수(상관 계수) : r
    항상 부등식 -1 <= r <= 1을 만족시키며,
    양의 상관 관계가 있을 경우 : r > 0
    음의 상관 관계가 있을 경우 : r < 0
    무상관                    : r = 0
    이 된다..
"""


## 다수 변수간의 상관 관계 계산
# 0 ~ 99 까지의 값
x = [i for i in range(100)]

# 0 ~ 99 까지의 값의 제곱
y = [i**2 for i in range(100)]

# z 변수 추가
z = [100 * np.sin(3.14*i/100) for i in range(0, 100)]

result_3 = np.corrcoef([x, y, z])
print(result_3)
'''
[[ 1.          0.96764439  0.03763255]
 [ 0.96764439  1.         -0.21532645]
 [ 0.03763255 -0.21532645  1.        ]]
'''


## 상관 계수
"""
상관 계수는
1. 두 변수간의 밀접도만 측정 가능.
   관계의 형태는 알 수 없다.

2. 두 변수간의 선형관계만 의미가 있고,
    비선형 관계에서는 사용될 수 없다!!!!
"""
